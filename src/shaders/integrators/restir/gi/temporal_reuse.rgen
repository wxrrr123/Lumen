#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_shader_atomic_float : require
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
#extension GL_EXT_shader_16bit_storage : require

#include "restirgi_commons.h"
#include "../../../commons.glsl"
layout(location = 0) rayPayloadEXT HitPayload payload;
layout(location = 1) rayPayloadEXT AnyHitPayload any_hit_payload;
#include "restirgi_commons.glsl"
#define M_MAX 30

RestirSamples samples = RestirSamples(scene_desc.restir_samples_addr);
RestirSamples old_samples = RestirSamples(scene_desc.restir_samples_old_addr);
Reservoirs temp_reservoirs = Reservoirs(scene_desc.temporal_reservoir_addr);
Reservoirs spatial_reservoirs = Reservoirs(scene_desc.spatial_reservoir_addr);

#define tr temp_reservoirs.d[offset(pingpong ^ 1) + pixel_idx]
void main() {
    const uint pingpong = (pc.total_frame_num % 2);
    const vec2 pixel = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    const ReservoirSample s = samples.d[pixel_idx];
    Reservoir r;
    if (length(vec3(s.n_s)) == 0.0) {
        init_reservoir(r);
        tr.w_sum = r.w_sum;
        tr.W = r.W;
        tr.m = r.m;
        tr.s = r.s;
        spatial_reservoirs.d[offset(pingpong ^ 1) + pixel_idx] = r;
        return;
    }
    if (pc.do_spatiotemporal == 0) {
        init_reservoir(r);
    } else {
        vec4 prev_pos = ubo.prev_view * vec4(s.x_v, 1);
        prev_pos /= prev_pos.z;
        prev_pos = -ubo.prev_projection * prev_pos;
        const vec2 prev_ndc = prev_pos.xy;
        ivec2 prev_coords = ivec2(0.5 * (1 + prev_ndc) * gl_LaunchSizeEXT.xy);
        bool reprojection_failed = true;
        uint prev_coords_idx;
        if (prev_coords.x >= 0 && prev_coords.x < gl_LaunchSizeEXT.x &&
            prev_coords.y >= 0 && prev_coords.y < gl_LaunchSizeEXT.y) {
            prev_coords_idx = prev_coords.x * pc.size_y + prev_coords.y;
            if (similar(samples.d[prev_coords_idx], old_samples.d[pixel_idx])) {
                reprojection_failed = false;
            }
        }
        if (!reprojection_failed) {
            r = temp_reservoirs.d[offset(pingpong) + prev_coords_idx];
        } else {
            // Reprojection failed, reset both reservoirs
            // Temporal
            init_reservoir(r);
            // Spatial
            spatial_reservoirs.d[offset(pingpong ^ 1) + pixel_idx] = r;
        }
    }
    Reservoir r_new;
    r_new.w_sum = 0;
    r_new.W = float16_t(0.0); // [FIX] 賦值修正
    r_new.m = 0;
    const float phat = p_hat(vec3(s.L_o)); // [FIX] p_hat 輸入改 vec3
    const float w = phat / float(s.p_q);   // [FIX] p_q 轉 float
    update_reservoir(r_new, s, w);

    // [FIX] 計算 W 時，要把所有變數轉成 float 計算，最後再轉回 float16_t
    r_new.W = phat == 0 ? float16_t(0.0) : float16_t(r_new.w_sum / (float(r_new.m) * phat));

    Reservoir r_t;
    r_t.w_sum = 0;
    r_t.W = float16_t(0.0); // [FIX] 賦值修正
    r_t.m = 0;

    // [FIX] 混合乘法修正： uint * float16 * float -> 全轉 float
    // Combine new
    update_reservoir(r_t, r_new.s, float(r_new.m) * float(r_new.W) * phat);
    // Combine previous (注意 p_hat 輸入要轉 vec3)
    update_reservoir(r_t, r.s, float(r.m) * float(r.W) * p_hat(vec3(r.s.L_o)));

    uint mval = r.m;
    const float new_phat = p_hat(vec3(r_t.s.L_o)); // [FIX] 輸入轉 vec3
    if (new_phat > 0) {
        mval++;
    }
    r_t.m = min(r.m + 1, M_MAX);
    
    // [FIX] 最終 W 計算
    r_t.W = (new_phat * float(mval) == 0.0) ? 
             float16_t(0.0) : 
             float16_t(r_t.w_sum / (float(mval) * new_phat));

    tr.w_sum = r_t.w_sum;
    tr.W = r_t.W;
    tr.m = r_t.m;
    tr.s = r_t.s;
}